

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import soot.Body;
import soot.Hierarchy;
import soot.Local;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.ValueBox;
import soot.jimple.ArrayRef;
import soot.jimple.AssignStmt;
import soot.jimple.CaughtExceptionRef;
import soot.jimple.ClassConstant;
import soot.jimple.FieldRef;
import soot.jimple.IdentityStmt;
import soot.jimple.InstanceFieldRef;
import soot.jimple.InstanceInvokeExpr;
import soot.jimple.StaticInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.Jimple;
import soot.jimple.ParameterRef;
import soot.jimple.ReturnStmt;
import soot.jimple.Stmt;
import soot.toolkits.graph.DirectedGraph;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.FlowSet;
import soot.toolkits.scalar.ForwardFlowAnalysis;
import soot.toolkits.scalar.SimpleLiveLocals;
import soot.toolkits.scalar.SimpleLocalUses;
import soot.toolkits.scalar.SmartLocalDefs;
import soot.util.Chain;



public class ByteForwardFlowAnalysis extends ForwardFlowAnalysis{
    private FlowSet emptySet = new ArraySparseSet();
    private SmartLocalDefs localDefs;
	private SootMethod method_;
	private ExceptionalUnitGraph eug;
    private Map<Unit, ArraySparseSet> unitToSet = new HashMap<Unit, ArraySparseSet>();
	private Map<Value,String> factToSource=new HashMap<Value,String>();
	// private ArrayList<String> sourcemethods=new ArrayList<String>();
	// private ArrayList<String> sinkmethods=new ArrayList<String>();


    public ByteForwardFlowAnalysis(DirectedGraph graph, SootMethod method){
		super(graph);
		
		this.method_ = method;

		if(!method.hasActiveBody())
			return;


			SourceSinkDetection.main(null);

			System.out.println("sources");
			System.out.println(SourceSinkDetection.sources);
			System.out.println("sinks");
			System.out.println(SourceSinkDetection.sinks);
			// sourcemethods=SourceSinkDetection.sources.get("Calculator");
			// sinkmethods=SourceSinkDetection.sinks.get("Calculator");



		for(Iterator it = graph.iterator(); it.hasNext();){
			Unit unit = (Unit) it.next();
			unitToSet.put(unit, new ArraySparseSet());
		}

		Body body = method.getActiveBody();
		eug = new ExceptionalUnitGraph(body);
		localDefs = new SmartLocalDefs(eug, new SimpleLiveLocals(eug));
		doAnalysis();

	}



    @Override
	protected void copy(Object src, Object tgt){
		
		FlowSet s = (FlowSet) src;
		FlowSet t = (FlowSet) tgt;
		s.copy(t);
	}

	@Override
	protected void merge(Object in1, Object in2, Object out){
		
		FlowSet i1 = (FlowSet) in1, i2 = (FlowSet) in2, o = (FlowSet) out;
		i1.union(i2, o);
	}

    @Override
	protected void flowThrough(Object in, Object callNode, Object out){


        Unit unit = (Unit) callNode;
		FlowSet predFactSet = (FlowSet) in;
		Stmt stmt = (Stmt) unit;

		System.out.println("In for unit-"+unit);
		System.out.println(predFactSet);

		System.out.println("Fact to source for unit-"+unit);
		System.out.println(factToSource);


		ArraySparseSet uFlowIntoThis = unitToSet.get(unit);

		



		if(stmt.containsInvokeExpr()){
			System.out.println("found invoke expression");
			InvokeExpr invokeExpr=stmt.getInvokeExpr();
			if(invokeExpr instanceof StaticInvokeExpr){

				System.out.println("found static invoke expression");
				SootMethod method=invokeExpr.getMethod();
				String mName=method.getName();
				

				if(SourceSinkDetection.isSource(mName)){
					System.out.println("found source method");
					List<ValueBox> leftOp=unit.getDefBoxes();
					for(ValueBox leftvb:leftOp){
						Value leftval=leftvb.getValue();
						System.out.println("print sink val method: "+leftval);
						System.out.println(factToSource);
						uFlowIntoThis.add(leftval);

						factToSource.put(leftval, mName);

						System.out.println(factToSource);
						
						//System.out.println("uflowIntoThis");
						//System.out.println(uFlowIntoThis);
					}


				}

				if(SourceSinkDetection.isSink(mName)){
					List<Value> vals=invokeExpr.getArgs();
					System.out.println("found sink method");

					for(Value v:vals){
						if (predFactSet.contains(v)){
							String srcmethod=this.factToSource.get(v);
							System.out.println("*******souce and sink pair found*********"+" source:"+srcmethod+" sink: "+mName);
							List<ValueBox> leftOp=unit.getDefBoxes();
							for(ValueBox leftvb:leftOp){
								Value leftval=leftvb.getValue();
								uFlowIntoThis.add(leftval);

								factToSource.put(leftval, srcmethod);
						
								//System.out.println("uflowIntoThis");
								System.out.println(uFlowIntoThis);
					}


						}
					}


				}

			}
		}
		
		if(stmt instanceof AssignStmt){
			System.out.println("assignment statement is coming :");

			List<ValueBox> rightOp=unit.getUseBoxes();

			for(ValueBox rightvb:rightOp){
				Value rightval=rightvb.getValue();
				if(predFactSet.contains(rightval)){
					String srcmethod=factToSource.get(rightval);
					System.out.println("assignment srcmethod:"+srcmethod+"rightval:"+rightval);
					List<ValueBox> leftOp=unit.getDefBoxes();
					for(ValueBox leftvb:leftOp){
						Value leftval=leftvb.getValue();
						uFlowIntoThis.add(leftval);
						factToSource.put(leftval,srcmethod);
						System.out.println("uflowIntoThis");
						System.out.println(uFlowIntoThis);
					}

				}




			}



		}
		predFactSet.union(uFlowIntoThis);
		System.out.println("out"+predFactSet);
		copy(predFactSet,out);



		
	}








































		
	// 	// take care of instance invoke
	// 	if(stmt.containsInvokeExpr()){

	// 		InvokeExpr invoke = stmt.getInvokeExpr();
	// 		if(invoke instanceof InstanceInvokeExpr){
	// 			InstanceInvokeExpr iie = (InstanceInvokeExpr) invoke;
	// 			Value base = iie.getBase();
	// 			System.out.println(base+"---this is base ----Instance Invoke-----");
	// 			List<Value> vals = iie.getArgs();

	// 			System.out.println(vals+"---this is args-----Instance Invoke------");

	// 			if(base instanceof Local){
	// 				List<Unit> localDefUs = localDefs.getDefsOfAt((Local) base, stmt);

	// 				System.out.println(localDefUs+"---this is localdefs-----Instance Invoke------");


	// 				for(Unit u : localDefUs){
	// 					ArraySparseSet baseSet;
	// 					if(unitToSet.containsKey(u))
	// 						baseSet= unitToSet.get(u);
	// 					else
	// 						baseSet = (ArraySparseSet) newInitialFlow();
	// 				}
    //             }
    //         }
	// 		if(invoke instanceof StaticInvokeExpr){
	// 			StaticInvokeExpr iie = (StaticInvokeExpr) invoke;
				
	// 			List<Value> vals = iie.getArgs();

	// 			System.out.println(vals+"---this is args-----static invoke-----");
    //    		}
	// 	}
	// }
		

        // if(stmt instanceof AssignStmt){
		// 	Value leftVal = ((AssignStmt) stmt).getLeftOp();
		// 	if(leftVal instanceof InstanceFieldRef){
		// 		Value baseV = ((InstanceFieldRef)leftVal).getBase();
				
		// 		if(baseV instanceof Local){
		// 			List<Unit> baseDefs = localDefs.getDefsOfAt((Local)baseV, stmt);
		// 			for(Unit baseDef : baseDefs){
		// 				unitToSet.get(baseDef).union(uFlowIntoThis);
		// 			}
		// 		}
		// 	}
		// }
    

    @Override
	protected Object entryInitialFlow(){
		

		return emptySet.clone();
	}

	@Override
	protected Object newInitialFlow(){
		

		return emptySet.clone();
	}

    public Map<Unit, ArraySparseSet> getUnitToSet(){
		
		return this.unitToSet;
	}
}   







