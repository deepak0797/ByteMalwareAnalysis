
import java.util.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import soot.Body;
import soot.Hierarchy;
import soot.Local;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.ValueBox;
import soot.jimple.ArrayRef;
import soot.jimple.AssignStmt;
import soot.jimple.CaughtExceptionRef;
import soot.jimple.ClassConstant;
import soot.jimple.FieldRef;
import soot.jimple.IdentityStmt;
import soot.jimple.InstanceFieldRef;
import soot.jimple.InstanceInvokeExpr;
import soot.jimple.StaticInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.Jimple;
import soot.jimple.ParameterRef;
import soot.jimple.ReturnStmt;
import soot.jimple.Stmt;
import soot.toolkits.graph.DirectedGraph;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.FlowSet;
import soot.toolkits.scalar.ForwardFlowAnalysis;
import soot.toolkits.scalar.SimpleLiveLocals;
import soot.toolkits.scalar.SimpleLocalUses;
import soot.toolkits.scalar.SmartLocalDefs;
import soot.util.Chain;

public class ByteForwardFlowAnalysis extends ForwardFlowAnalysis {
	private FlowSet emptySet = new ArraySparseSet();
	private SmartLocalDefs localDefs;
	private SootMethod method_;
	private ByteInterProceduralAnalysis inter_;
	private ByteMethodSummary methodSummary_;
	private ExceptionalUnitGraph eug;
	private Map<Unit, ArraySparseSet> unitToSet = new HashMap<Unit, ArraySparseSet>();// hash map for each unit with all
																						// the significant sensitive
																						// facts until that node in a
																						// method
	private Map<Value, ArrayList<String>> factToSource = new HashMap<Value, ArrayList<String>>();// hash map for each
																									// significant fact
																									// in a method
																									// (fact:<list of
																									// source methods>)
	// private ArrayList<String> sourcemethods=new ArrayList<String>();
	// private ArrayList<String> sinkmethods=new ArrayList<String>();
	//private HashSet<String> srcToSinkPairHashSet = new HashSet<>();
	private Set<Value> argSet = new HashSet<Value>();
	private ArrayList<Value> argList = new ArrayList<Value>();

	public ByteForwardFlowAnalysis(DirectedGraph graph, SootMethod method, Body body, ByteInterProceduralAnalysis inter,
			ByteMethodSummary methodSummary) {
		super(graph);

		this.method_ = method;
		this.inter_ = inter;
		this.methodSummary_ = methodSummary;

		if (!method.hasActiveBody())
			return;
		

		for (Iterator it = graph.iterator(); it.hasNext();) {
			Unit unit = (Unit) it.next();
			unitToSet.put(unit, new ArraySparseSet());
		}

		eug = new ExceptionalUnitGraph(body);
		localDefs = new SmartLocalDefs(eug, new SimpleLiveLocals(eug));

		for (int i = 0; i < method.getParameterCount(); i++) {
			Value argValue = method.getActiveBody().getParameterLocal(i);
			this.argSet.add(argValue);
			this.argList.add(argValue);
			ArrayList<String> argSrcList = new ArrayList<>();
			argSrcList.add("ARG" + Integer.toString(i));
			factToSource.put(argValue, argSrcList);
		}

		System.out.println(factToSource);

		doAnalysis();

	}

	@Override
	protected void copy(Object src, Object tgt) {

		FlowSet s = (FlowSet) src;
		FlowSet t = (FlowSet) tgt;
		s.copy(t);
	}

	@Override
	protected void merge(Object in1, Object in2, Object out) {

		FlowSet i1 = (FlowSet) in1, i2 = (FlowSet) in2, o = (FlowSet) out;
		i1.union(i2, o);
	}

	@Override
	protected void flowThrough(Object in, Object callNode, Object out) {

		Unit unit = (Unit) callNode;
		FlowSet predFactSet = (FlowSet) in;// predfactset is set of all sensitive facts generated before this node in
											// cfg
		Stmt stmt = (Stmt) unit;

		ArraySparseSet uFlowIntoThis = unitToSet.get(unit);// set to keep track of newly generated sensitive facts for
															// node that we are analyzing

		if (stmt.containsInvokeExpr()) {

			InvokeExpr invokeExpr = stmt.getInvokeExpr();

			if (invokeExpr instanceof InvokeExpr) {

				SootMethod method = invokeExpr.getMethod();
				String mName = method.getName();
				String decClass = method.getDeclaringClass().getName();

				if (SourceSinkDetection.isSource(decClass, mName)) {

					List<ValueBox> leftOp = unit.getDefBoxes();
					for (ValueBox leftvb : leftOp) {
						Value leftval = leftvb.getValue();

						uFlowIntoThis.add(leftval);

						if (factToSource.containsKey(leftval)) {
							factToSource.get(leftval).add(method.toString());
						} else {
							ArrayList<String> newList = new ArrayList<String>();
							newList.add(method.toString());
							factToSource.put(leftval, newList);

						}

					}

				}

				if (SourceSinkDetection.isSink(decClass, mName)) {

					List<Value> vals = invokeExpr.getArgs();
					SootMethod invokMethod = invokeExpr.getMethod();

					for (Value v : vals) {
						if (predFactSet.contains(v)) {
							if (factToSource.containsKey(v)) {
								List<String> srcMethods = factToSource.get(v);
								for (String srcmethod : srcMethods) {
									if (srcmethod.startsWith("ARG")) {
										int len = srcmethod.length();
										int argIdx = (int) srcmethod.charAt(len - 1) - 48;

										if (this.methodSummary_.getArgToSink().containsKey(argIdx)) {
											this.methodSummary_.getArgToSink().get(argIdx).add(method.toString());

										}
										HashSet<String> argSinkSet = new HashSet<>();
										argSinkSet.add(method.toString());
										this.methodSummary_.getArgToSink().put(argIdx, argSinkSet);

									}

									else {
										System.out.println("*******souce and sink pair found*********" + " source:"
												+ srcmethod + " sink: " + method.toString());
										String sinkMethod = decClass + ":" + mName;
										SootAnalysis.srcToSinkPairHashSet.add("(" + srcmethod + "," + method.toString() + ")");
									}

								}
							}

						}
					}

				}
				System.out.println(invokeExpr);

				if (stmt instanceof AssignStmt && !SourceSinkDetection.isSource(decClass, mName)
						&& !SourceSinkDetection.isSink(decClass, mName)
						&& ByteInterProceduralAnalysis.methodSummaryMap.containsKey(method)) {

					System.out.println("non source non sink method found " + method);

					ByteMethodSummary summary = ByteInterProceduralAnalysis.methodSummaryMap.get(method);
					ArraySparseSet values = new ArraySparseSet();
					Map<Value, ArrayList<String>> valuesSource = new HashMap<Value, ArrayList<String>>();

					inter_.analysecall(method, unit, stmt, values, predFactSet, factToSource, valuesSource);

					if (!values.isEmpty()) {
						uFlowIntoThis.union(values);

					}
					if (valuesSource.size() > 0) {
						Set<Value> vals = valuesSource.keySet();
						for (Value val : vals) {
							factToSource.put(val, valuesSource.get(val));
						}
					}

				}
			}
		}

		if (stmt instanceof AssignStmt && !stmt.containsInvokeExpr()) {

			Value leftV = ((AssignStmt) stmt).getLeftOp();

			Value rightV = ((AssignStmt) stmt).getRightOp();

			if (leftV instanceof InstanceFieldRef) {

				Value base = ((InstanceFieldRef) leftV).getBase();

				if (predFactSet.contains(rightV)) {
					List<String> srcMethods = factToSource.get(rightV);
					uFlowIntoThis.add(base);

					if (factToSource.containsKey(base)) {
						factToSource.get(base).addAll(srcMethods);
						Set<String> sourceSet = new LinkedHashSet<String>();
						sourceSet.addAll(factToSource.get(base));
						factToSource.get(base).clear();
						factToSource.get(base).addAll(sourceSet);
					} else {
						ArrayList<String> newList = new ArrayList<String>();
						newList.addAll(srcMethods);
						factToSource.put(base, newList);

					}

				}
			}

			if (leftV instanceof ArrayRef) {

				Value base = ((ArrayRef) leftV).getBase();

				if (predFactSet.contains(rightV)) {
					List<String> srcMethods = factToSource.get(rightV);
					uFlowIntoThis.add(base);

					if (factToSource.containsKey(base)) {
						factToSource.get(base).addAll(srcMethods);
						Set<String> sourceSet = new LinkedHashSet<String>();
						sourceSet.addAll(factToSource.get(base));
						factToSource.get(base).clear();
						factToSource.get(base).addAll(sourceSet);
					} else {
						ArrayList<String> newList = new ArrayList<String>();
						newList.addAll(srcMethods);
						factToSource.put(base, newList);

					}

				}
			}

			List<ValueBox> rightOp = unit.getUseBoxes();

			for (ValueBox rightvb : rightOp) {
				Value rightval = rightvb.getValue();

				if (predFactSet.contains(rightval)) {
					if (factToSource.containsKey(rightval)) {
						List<String> srcMethods = factToSource.get(rightval);

						List<ValueBox> leftOp = unit.getDefBoxes();
						for (ValueBox leftvb : leftOp) {
							Value leftval = leftvb.getValue();
							uFlowIntoThis.add(leftval);

							if (factToSource.containsKey(leftval)) {
								factToSource.get(leftval).addAll(srcMethods);
								Set<String> sourceSet = new LinkedHashSet<String>();
								sourceSet.addAll(factToSource.get(leftval));
								factToSource.get(leftval).clear();
								factToSource.get(leftval).addAll(sourceSet);
							} else {
								ArrayList<String> newList = new ArrayList<String>();
								newList.addAll(srcMethods);
								factToSource.put(leftval, newList);

							}

						}

					}

				}

			}

		}

		if (stmt instanceof ReturnStmt) {


			
        
			ValueBox opBox = ((ReturnStmt) stmt).getOpBox();

			Value opval = opBox.getValue();

			System.out.println("return statemet operand"+opval);

			System.out.println(factToSource);

			FlowSet uFlowIntoThisFlowset = (FlowSet) uFlowIntoThis;

			if (predFactSet.contains(opval) || uFlowIntoThisFlowset.contains(opval) || factToSource.containsKey(opval)) {

				ArrayList<String> srcList = factToSource.get(opval);

				for (String src : srcList) {
					if (!src.startsWith("ARG")) {
						this.methodSummary_.getsrcToReturn().add(src);

					} else {
						int len = src.length();
						int argIdx = (int) src.charAt(len - 1) - 48;

						if (this.methodSummary_.getArgToReturn().containsKey(argIdx)
								&& !this.methodSummary_.getArgToReturn().get(argIdx)) {
							this.methodSummary_.getArgToReturn().put(argIdx, true);

						} else if (!this.methodSummary_.getArgToReturn().containsKey(argIdx)) {
							this.methodSummary_.getArgToReturn().put(argIdx, true);

						}

					}

				}

			}

		}
		predFactSet.union(uFlowIntoThis);// union of newly generated facts with exisiting facts
		// System.out.println("out"+predFactSet);
		copy(predFactSet, out);// give the union of newly generated facts with exisiting facts to out for the
								// next nodes for doanalysis

		// System.out.println("Unit to Set "+unitToSet);

	}

	protected ByteMethodSummary getMethodSummary() {
		return this.methodSummary_;
	}

	@Override
	protected Object entryInitialFlow() {

		FlowSet entrySet = emptySet.clone();

		// populate the in set with the arguments for every entry set
		for (Value argVal : this.argSet) {
			entrySet.add(argVal);
		}
		return entrySet;
	}

	@Override
	protected Object newInitialFlow() {

		return emptySet.clone();
	}

	public Map<Unit, ArraySparseSet> getUnitToSet() {

		return this.unitToSet;
	}

	public HashSet<String> getsrcToSinkSet() {

		return SootAnalysis.srcToSinkPairHashSet;
	}
}
