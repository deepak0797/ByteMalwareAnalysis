
import java.util.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import soot.Body;
import soot.Hierarchy;
import soot.Local;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.ValueBox;
import soot.jimple.ArrayRef;
import soot.jimple.AssignStmt;
import soot.jimple.CaughtExceptionRef;
import soot.jimple.ClassConstant;
import soot.jimple.FieldRef;
import soot.jimple.IdentityStmt;
import soot.jimple.InstanceFieldRef;
import soot.jimple.InstanceInvokeExpr;
import soot.jimple.StaticInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.Jimple;
import soot.jimple.ParameterRef;
import soot.jimple.ReturnStmt;
import soot.jimple.Stmt;
import soot.toolkits.graph.DirectedGraph;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.FlowSet;
import soot.toolkits.scalar.ForwardFlowAnalysis;
import soot.toolkits.scalar.SimpleLiveLocals;
import soot.toolkits.scalar.SimpleLocalUses;
import soot.toolkits.scalar.SmartLocalDefs;
import soot.util.Chain;



public class ByteForwardFlowAnalysis extends ForwardFlowAnalysis{
    private FlowSet emptySet = new ArraySparseSet();
    private SmartLocalDefs localDefs;
	private SootMethod method_;
	private ByteInterProceduralAnalysis inter_;
	private ByteMethodSummary methodSummary_;
	private ExceptionalUnitGraph eug;
    private Map<Unit, ArraySparseSet> unitToSet = new HashMap<Unit, ArraySparseSet>();//hash map for each unit with all the significant sensitive facts until that node in a method
	private Map<Value,ArrayList<String>> factToSource=new HashMap<Value,ArrayList<String>>();//hash map for each significant fact in a method (fact:<list of source methods>)
	// private ArrayList<String> sourcemethods=new ArrayList<String>();
	// private ArrayList<String> sinkmethods=new ArrayList<String>();
    private HashSet<String> srcToSinkPairHashSet = new HashSet<>();
	private Set<Value> argSet = new HashSet<Value>();
	private ArrayList<Value> argList=new ArrayList<Value>();

    public ByteForwardFlowAnalysis(DirectedGraph graph, SootMethod method,Body body,ByteInterProceduralAnalysis inter,ByteMethodSummary methodSummary){
		super(graph);
		
		this.method_ = method;
		this.inter_=inter;
		this.methodSummary_=methodSummary;

		 if(!method.hasActiveBody())
		 	return;
			SourceSinkDetection.main(null);
			// System.out.println("sources");
			// System.out.println(SourceSinkDetection.sources);
			// System.out.println("sinks");
			// System.out.println(SourceSinkDetection.sinks);
			// sourcemethods=SourceSinkDetection.sources.get("Calculator");
			// sinkmethods=SourceSinkDetection.sinks.get("Calculator");
		for(Iterator it = graph.iterator(); it.hasNext();){
			Unit unit = (Unit) it.next();
			unitToSet.put(unit, new ArraySparseSet());
		}

		//Body body = method.getActiveBody();
		eug = new ExceptionalUnitGraph(body);
		localDefs = new SmartLocalDefs(eug, new SimpleLiveLocals(eug));

		
		//get the the list of args this function has and use it for inter analysis
		for (int i = 0; i < method.getParameterCount(); i++) {
			Value argValue=method.getActiveBody().getParameterLocal(i);
			this.argSet.add(argValue);
			this.argList.add(argValue);
			ArrayList<String> argSrcList=new ArrayList<>();
			argSrcList.add("ARG"+Integer.toString(i));
			factToSource.put(argValue, argSrcList);
		   }

		//populate the factToSource with args 

		
		doAnalysis();

	}



    @Override
	protected void copy(Object src, Object tgt){
		
		FlowSet s = (FlowSet) src;
		FlowSet t = (FlowSet) tgt;
		s.copy(t);
	}

	@Override
	protected void merge(Object in1, Object in2, Object out){
		
		FlowSet i1 = (FlowSet) in1, i2 = (FlowSet) in2, o = (FlowSet) out;
		i1.union(i2, o);
	}

    @Override
	protected void flowThrough(Object in, Object callNode, Object out){


       //System.out.println("IN SET -----"+in);

        Unit unit = (Unit) callNode;
		FlowSet predFactSet = (FlowSet) in;//predfactset is set of all sensitive facts generated before this node in cfg
		Stmt stmt = (Stmt) unit;

		//System.out.println("In for unit-"+unit);
		//System.out.println(predFactSet);

		//System.out.println("Fact to source for unit-"+unit);
		//System.out.println(factToSource);


		ArraySparseSet uFlowIntoThis = unitToSet.get(unit);//set to keep track of newly generated sensitive facts for node that we are analyzing 

		



		if(stmt.containsInvokeExpr()){
			//System.out.println("found invoke expression");
			InvokeExpr invokeExpr=stmt.getInvokeExpr();

			if(invokeExpr instanceof InvokeExpr){

				//System.out.println("found  invoke expression");

				SootMethod method=invokeExpr.getMethod();
				String mName=method.getName();
				String decClass=method.getDeclaringClass().getName();
				

				if(SourceSinkDetection.isSource(decClass,mName)){
					//System.out.println("found source method");
					List<ValueBox> leftOp=unit.getDefBoxes();
					for(ValueBox leftvb:leftOp){
						Value leftval=leftvb.getValue();
						//System.out.println("print sink val method: "+leftval);
						//System.out.println(factToSource);
						uFlowIntoThis.add(leftval);
                        
						if(factToSource.containsKey(leftval)){
							factToSource.get(leftval).add(method.toString());
						}else{
							ArrayList<String> newList = new ArrayList<String>();
							newList.add(method.toString());
							factToSource.put(leftval, newList);

						}
						

						//System.out.println(factToSource);
						
						
					}


				}

				if(SourceSinkDetection.isSink(decClass,mName)){


					List<Value> vals=invokeExpr.getArgs();
					SootMethod invokMethod=invokeExpr.getMethod();
					//System.out.println("found sink method"+method);



					for(Value v:vals){
						if (predFactSet.contains(v)){
							if(factToSource.containsKey(v)){
								List<String>  srcMethods=factToSource.get(v);
								for (String srcmethod:srcMethods){
									if(srcmethod.startsWith("ARG")){
										int len=srcmethod.length();
										int argIdx=(int)srcmethod.charAt(len-1)-48;

										if(this.methodSummary_.getArgToSink().containsKey(argIdx)){
											this.methodSummary_.getArgToSink().get(argIdx).add(method.toString());
											
										}
										HashSet<String> argSinkSet=new HashSet<>();
										argSinkSet.add(method.toString());
										this.methodSummary_.getArgToSink().put(argIdx, argSinkSet);
			

										

									}


									else{
										System.out.println("*******souce and sink pair found*********"+" source:"+srcmethod+" sink: "+method.toString());
										String sinkMethod=decClass+":"+mName;
										srcToSinkPairHashSet.add("("+srcmethod+","+method.toString()+")");
									}

									
								}
							}
							


						}
					}

					// for(int j=0;j<argList.size();j++){
					// 	Value val=argList.get(j);
					// 	if (vals.contains(val)){
					// 		if(this.methodSummary_.getArgToSink().containsKey(j)){
					// 			this.methodSummary_.getArgToSink().get(j).add(method.toString());
								
					// 		}
					// 		HashSet<String> argSinkSet=new HashSet<>();
					// 		argSinkSet.add(method.toString());
					// 		this.methodSummary_.getArgToSink().put(j, argSinkSet);



					// 	}
						
					// }


				}
                
				if(stmt instanceof AssignStmt && !SourceSinkDetection.isSource(decClass,mName)&&!SourceSinkDetection.isSink(decClass,mName) && ByteInterProceduralAnalysis.methodSummaryMap.containsKey(method)){

					System.out.println("non source non sink method found "+method);

					ByteMethodSummary summary=ByteInterProceduralAnalysis.methodSummaryMap.get(method);
					ArraySparseSet values = new ArraySparseSet();
					Map<Value,ArrayList<String>> valuesSource=new HashMap<Value,ArrayList<String>>();


                     
					inter_.analysecall(method,unit,stmt,values,predFactSet,factToSource,valuesSource);

					if(!values.isEmpty()){
						uFlowIntoThis.union(values);
						
					}
					if(valuesSource.size()>0){
						Set<Value> vals=valuesSource.keySet();
						for(Value val:vals){
							factToSource.put(val,valuesSource.get(val));
						}
					}




				}
			}
		}
		
		if(stmt instanceof AssignStmt && !stmt.containsInvokeExpr()){

			Value leftV = ((AssignStmt) stmt).getLeftOp();
			//System.out.println(leftV+" This is out leftV ");

			Value rightV = ((AssignStmt) stmt).getRightOp();
			//System.out.println(rightV+" This is out rightV ");


			if(leftV instanceof InstanceFieldRef) {
				
				Value base = ((InstanceFieldRef) leftV).getBase();
				//System.out.println("*****Fieldref BASE*******"+base);

				if (predFactSet.contains(rightV)){
					List<String>  srcMethods=factToSource.get(rightV);
					uFlowIntoThis.add(base);

					if(factToSource.containsKey(base)){
						factToSource.get(base).addAll(srcMethods);
						Set<String> sourceSet = new LinkedHashSet<String>();
						sourceSet.addAll(factToSource.get(base));
						factToSource.get(base).clear();
						factToSource.get(base).addAll(sourceSet);
					}else{
						ArrayList<String> newList = new ArrayList<String>();
						newList.addAll(srcMethods);
						factToSource.put(base, newList);

					}


				}
			}
			

			if(leftV instanceof ArrayRef){
				
				Value base = ((ArrayRef) leftV).getBase();
				//System.out.println("*****ARRAY BASE*******"+base);

				if (predFactSet.contains(rightV)){
					List<String>  srcMethods=factToSource.get(rightV);
					uFlowIntoThis.add(base);

					if(factToSource.containsKey(base)){
						factToSource.get(base).addAll(srcMethods);
						Set<String> sourceSet = new LinkedHashSet<String>();
						sourceSet.addAll(factToSource.get(base));
						factToSource.get(base).clear();
						factToSource.get(base).addAll(sourceSet);
					}else{
						ArrayList<String> newList = new ArrayList<String>();
						newList.addAll(srcMethods);
						factToSource.put(base, newList);

					}


				}
			}



			List<ValueBox> rightOp=unit.getUseBoxes();

			for(ValueBox rightvb:rightOp){
				Value rightval=rightvb.getValue();

				if(predFactSet.contains(rightval)){
					if(factToSource.containsKey(rightval)){
						List<String>  srcMethods=factToSource.get(rightval);
						//System.out.println("assignment srcmethod:"+srcMethods+"rightval:"+rightval);
						List<ValueBox> leftOp=unit.getDefBoxes();
						for(ValueBox leftvb:leftOp){
							Value leftval=leftvb.getValue();
							uFlowIntoThis.add(leftval);

							if(factToSource.containsKey(leftval)){
								factToSource.get(leftval).addAll(srcMethods);
								Set<String> sourceSet = new LinkedHashSet<String>();
								sourceSet.addAll(factToSource.get(leftval));
								factToSource.get(leftval).clear();
								factToSource.get(leftval).addAll(sourceSet);
							}else{
								ArrayList<String> newList = new ArrayList<String>();
								newList.addAll(srcMethods);
								factToSource.put(leftval, newList);
	
							}

							
							//System.out.println("uflowIntoThis");
							//System.out.println(uFlowIntoThis);
						}

						
						
					}
					

				}




			}



		}

        if(stmt instanceof ReturnStmt){

			ValueBox opBox=((ReturnStmt) stmt).getOpBox();

			Value opval=opBox.getValue();

            FlowSet uFlowIntoThisFlowset = (FlowSet) uFlowIntoThis;


			if(predFactSet.contains(opval) || uFlowIntoThisFlowset.contains(opval)){

				ArrayList<String> srcList=factToSource.get(opval);
				

				for(String src:srcList){
					if(!src.startsWith("ARG")){
						this.methodSummary_.getsrcToReturn().add(src);

					}
					else{
						int len=src.length();
						int argIdx=(int)src.charAt(len-1)-48;

						if(this.methodSummary_.getArgToReturn().containsKey(argIdx) && !this.methodSummary_.getArgToReturn().get(argIdx)){
							this.methodSummary_.getArgToReturn().put(argIdx, true);
							
						}
						else if (!this.methodSummary_.getArgToReturn().containsKey(argIdx)){
							this.methodSummary_.getArgToReturn().put(argIdx,true);
							
						}

					}
					
				}


			}


			// if(argList.contains(opval)){
			// 	int argIdx=argList.lastIndexOf(opval);

			// 	if(this.methodSummary_.getArgToReturn().containsKey(argIdx) && !this.methodSummary_.getArgToReturn().get(argIdx)){
			// 		this.methodSummary_.getArgToReturn().put(argIdx, true);
					
			// 	}
			// 	else if (!this.methodSummary_.getArgToReturn().containsKey(argIdx)){
			// 		this.methodSummary_.getArgToReturn().put(argIdx,true);
					
			// 	}


			// }



			



		}
		predFactSet.union(uFlowIntoThis);//union of newly generated facts with exisiting facts 
		//System.out.println("out"+predFactSet);
		copy(predFactSet,out);//give the union of newly generated facts with exisiting facts to out for the next nodes for doanalysis 

		//System.out.println("Unit to Set "+unitToSet);



		
	}


    protected ByteMethodSummary getMethodSummary(){
		return this.methodSummary_;
	}

    @Override
	protected Object entryInitialFlow(){
		
		FlowSet entrySet=emptySet.clone();

        //populate the in set with the arguments for every entry set
		for(Value argVal:this.argSet){
			entrySet.add(argVal);
		}
		return entrySet;
	}

	@Override
	protected Object newInitialFlow(){
		

		return emptySet.clone();
	}

    public Map<Unit, ArraySparseSet> getUnitToSet(){
		
		return this.unitToSet;
	}
	public HashSet<String> getsrcToSinkSet(){
		
		return this.srcToSinkPairHashSet;
	}
}   







