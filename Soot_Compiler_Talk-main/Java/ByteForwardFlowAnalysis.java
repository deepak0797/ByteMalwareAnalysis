

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import soot.Body;
import soot.Hierarchy;
import soot.Local;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.ValueBox;
import soot.jimple.ArrayRef;
import soot.jimple.AssignStmt;
import soot.jimple.CaughtExceptionRef;
import soot.jimple.ClassConstant;
import soot.jimple.FieldRef;
import soot.jimple.IdentityStmt;
import soot.jimple.InstanceFieldRef;
import soot.jimple.InstanceInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.Jimple;
import soot.jimple.ParameterRef;
import soot.jimple.ReturnStmt;
import soot.jimple.Stmt;
import soot.toolkits.graph.DirectedGraph;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.FlowSet;
import soot.toolkits.scalar.ForwardFlowAnalysis;
import soot.toolkits.scalar.SimpleLiveLocals;
import soot.toolkits.scalar.SimpleLocalUses;
import soot.toolkits.scalar.SmartLocalDefs;
import soot.util.Chain;


public class ByteForwardFlowAnalysis extends ForwardFlowAnalysis{
    private FlowSet emptySet = new ArraySparseSet();
    private SmartLocalDefs localDefs;
	private SootMethod method_;
	private ExceptionalUnitGraph eug;
    private Map<Unit, ArraySparseSet> unitToSet = new HashMap<Unit, ArraySparseSet>();


    public ByteForwardFlowAnalysis(DirectedGraph graph, SootMethod method){
		super(graph);
		
		this.method_ = method;

		if(!method.hasActiveBody())
			return;

		for(Iterator it = graph.iterator(); it.hasNext();){
			Unit unit = (Unit) it.next();
			unitToSet.put(unit, new ArraySparseSet());
		}

		Body body = method.getActiveBody();
		eug = new ExceptionalUnitGraph(body);
		localDefs = new SmartLocalDefs(eug, new SimpleLiveLocals(eug));
		doAnalysis();

	}



    @Override
	protected void copy(Object src, Object tgt){
		
		FlowSet s = (FlowSet) src;
		FlowSet t = (FlowSet) tgt;
		s.copy(t);
	}

	@Override
	protected void merge(Object in1, Object in2, Object out){
		
		FlowSet i1 = (FlowSet) in1, i2 = (FlowSet) in2, o = (FlowSet) out;
		i1.union(i2, o);
	}

    @Override
	protected void flowThrough(Object in, Object callNode, Object out){
		
		Unit unit = (Unit) callNode;
		Stmt stmt = (Stmt) unit;
		List<ValueBox> uses = unit.getUseBoxes();
		ArraySparseSet uFlowIntoThis = unitToSet.get(unit);
		
		// take care of instance invoke
		if(stmt.containsInvokeExpr()){

			InvokeExpr invoke = stmt.getInvokeExpr();
			if(invoke instanceof InstanceInvokeExpr){
				InstanceInvokeExpr iie = (InstanceInvokeExpr) invoke;
				Value base = iie.getBase();
				List<Value> vals = iie.getArgs();

				if(base instanceof Local){
					List<Unit> localDefUs = localDefs.getDefsOfAt((Local) base, stmt);

					for(Unit u : localDefUs){
						ArraySparseSet baseSet;
						if(unitToSet.containsKey(u)){
							baseSet= unitToSet.get(u);
						}else{
							baseSet = (ArraySparseSet) newInitialFlow();
						}
						ArraySparseSet previousBaseSet = new ArraySparseSet();
						baseSet.copy(previousBaseSet);

						for(Value val : vals){
							if(val instanceof ClassConstant){
								Chain<Local> locals = method_.getActiveBody().getLocals();
								Local localConst = Jimple.v().newLocal("$r" + locals.size(),
									RefType.v("java.lang.Object"));
								locals.add(localConst);
								AssignStmt constAssign = Jimple.v().newAssignStmt(localConst,
									val);
								baseSet.add((Unit)constAssign);
							}
							if(!(val instanceof Local))
								continue;

							List<Unit> defUs = localDefs.getDefsOfAt((Local) val, stmt);

							for(Unit valU : defUs){
								baseSet.add(valU);
								baseSet.union(unitToSet.get(valU));
							}
						}
						
						unitToSet.put(u, baseSet);
                    }
                }
            }
        }

        if(stmt instanceof AssignStmt){
			Value leftVal = ((AssignStmt) stmt).getLeftOp();
			if(leftVal instanceof InstanceFieldRef){
				Value baseV = ((InstanceFieldRef)leftVal).getBase();
				
				if(baseV instanceof Local){
					List<Unit> baseDefs = localDefs.getDefsOfAt((Local)baseV, stmt);
					for(Unit baseDef : baseDefs){
						unitToSet.get(baseDef).union(uFlowIntoThis);
					}
				}
			}
		}
    } 

    @Override
	protected Object entryInitialFlow(){
		

		return emptySet.clone();
	}

	@Override
	protected Object newInitialFlow(){
		

		return emptySet.clone();
	}

    public Map<Unit, ArraySparseSet> getUnitToSet(){
		
		return this.unitToSet;
	}
}   







