
import java.util.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import soot.Body;
import soot.Hierarchy;
import soot.Local;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.ValueBox;
import soot.jimple.ArrayRef;
import soot.jimple.AssignStmt;
import soot.jimple.CaughtExceptionRef;
import soot.jimple.ClassConstant;
import soot.jimple.FieldRef;
import soot.jimple.IdentityStmt;
import soot.jimple.InstanceFieldRef;
import soot.jimple.InstanceInvokeExpr;
import soot.jimple.StaticInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.Jimple;
import soot.jimple.ParameterRef;
import soot.jimple.ReturnStmt;
import soot.jimple.Stmt;
import soot.toolkits.graph.DirectedGraph;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.FlowSet;
import soot.toolkits.scalar.ForwardFlowAnalysis;
import soot.toolkits.scalar.SimpleLiveLocals;
import soot.toolkits.scalar.SimpleLocalUses;
import soot.toolkits.scalar.SmartLocalDefs;
import soot.util.Chain;



public class ByteForwardFlowAnalysis extends ForwardFlowAnalysis{
    private FlowSet emptySet = new ArraySparseSet();
    private SmartLocalDefs localDefs;
	private SootMethod method_;
	private ExceptionalUnitGraph eug;
    private Map<Unit, ArraySparseSet> unitToSet = new HashMap<Unit, ArraySparseSet>();//hash map for each unit with all the significant sensitive facts until that node in a method
	private Map<Value,ArrayList<String>> factToSource=new HashMap<Value,ArrayList<String>>();//hash map for each significant fact in a method (fact:<list of source methods>)
	// private ArrayList<String> sourcemethods=new ArrayList<String>();
	// private ArrayList<String> sinkmethods=new ArrayList<String>();


    public ByteForwardFlowAnalysis(DirectedGraph graph, SootMethod method){
		super(graph);
		
		this.method_ = method;

		if(!method.hasActiveBody())
			return;


			SourceSinkDetection.main(null);

			System.out.println("sources");
			System.out.println(SourceSinkDetection.sources);
			System.out.println("sinks");
			System.out.println(SourceSinkDetection.sinks);
			// sourcemethods=SourceSinkDetection.sources.get("Calculator");
			// sinkmethods=SourceSinkDetection.sinks.get("Calculator");



		for(Iterator it = graph.iterator(); it.hasNext();){
			Unit unit = (Unit) it.next();
			unitToSet.put(unit, new ArraySparseSet());
		}

		Body body = method.getActiveBody();
		eug = new ExceptionalUnitGraph(body);
		localDefs = new SmartLocalDefs(eug, new SimpleLiveLocals(eug));
		doAnalysis();

	}



    @Override
	protected void copy(Object src, Object tgt){
		
		FlowSet s = (FlowSet) src;
		FlowSet t = (FlowSet) tgt;
		s.copy(t);
	}

	@Override
	protected void merge(Object in1, Object in2, Object out){
		
		FlowSet i1 = (FlowSet) in1, i2 = (FlowSet) in2, o = (FlowSet) out;
		i1.union(i2, o);
	}

    @Override
	protected void flowThrough(Object in, Object callNode, Object out){


        Unit unit = (Unit) callNode;
		FlowSet predFactSet = (FlowSet) in;//predfactset is set of all sensitive facts generated before this node in cfg
		Stmt stmt = (Stmt) unit;

		System.out.println("In for unit-"+unit);
		System.out.println(predFactSet);

		System.out.println("Fact to source for unit-"+unit);
		System.out.println(factToSource);


		ArraySparseSet uFlowIntoThis = unitToSet.get(unit);//set to keep track of newly generated sensitive facts for node that we are analyzing 

		



		if(stmt.containsInvokeExpr()){
			System.out.println("found invoke expression");
			InvokeExpr invokeExpr=stmt.getInvokeExpr();

			if(invokeExpr instanceof InvokeExpr){

				System.out.println("found  invoke expression");

				SootMethod method=invokeExpr.getMethod();
				String mName=method.getName();
				String decClass=method.getDeclaringClass().getName();
				

				if(SourceSinkDetection.isSource(mName)){
					System.out.println("found source method");
					List<ValueBox> leftOp=unit.getDefBoxes();
					for(ValueBox leftvb:leftOp){
						Value leftval=leftvb.getValue();
						System.out.println("print sink val method: "+leftval);
						System.out.println(factToSource);
						uFlowIntoThis.add(leftval);
                        
						if(factToSource.containsKey(leftval)){
							factToSource.get(leftval).add(decClass+":"+mName);
						}else{
							ArrayList<String> newList = new ArrayList<String>();
							newList.add(decClass+":"+mName);
							factToSource.put(leftval, newList);

						}
						

						System.out.println(factToSource);
						
						
					}


				}

				if(SourceSinkDetection.isSink(mName)){
					List<Value> vals=invokeExpr.getArgs();
					System.out.println("found sink method");

					for(Value v:vals){
						if (predFactSet.contains(v)){
							if(factToSource.containsKey(v)){
								List<String>  srcMethods=factToSource.get(v);
								for (String srcmethod:srcMethods){
									System.out.println("*******souce and sink pair found*********"+" source:"+srcmethod+" sink: "+decClass+":"+mName);
								}
							}
							


						}
					}


				}

			}
		}
		
		if(stmt instanceof AssignStmt){
			Value leftV = ((AssignStmt) stmt).getLeftOp();
			Value rightV = ((AssignStmt) stmt).getRightOp();
			System.out.println(leftV+" This is out leftV ");
			System.out.println(rightV+" This is out rightV ");
			if(leftV instanceof FieldRef) {
				System.out.println(leftV+" This is ^^^^^^^^^^^^^^^^leftV ");
			}
			
			if(rightV instanceof FieldRef) {
				System.out.println(" This is ------------ right V "+rightV);
			}
			System.out.println("assignment statement is coming :");

			List<ValueBox> rightOp=unit.getUseBoxes();

			for(ValueBox rightvb:rightOp){
				Value rightval=rightvb.getValue();
				if(predFactSet.contains(rightval)){
					if(factToSource.containsKey(rightval)){
						List<String>  srcMethods=factToSource.get(rightval);
						System.out.println("assignment srcmethod:"+srcMethods+"rightval:"+rightval);
						List<ValueBox> leftOp=unit.getDefBoxes();
						for(ValueBox leftvb:leftOp){
							Value leftval=leftvb.getValue();
							uFlowIntoThis.add(leftval);

							if(factToSource.containsKey(leftval)){
								factToSource.get(leftval).addAll(srcMethods);
								Set<String> sourceSet = new LinkedHashSet<String>();
								sourceSet.addAll(factToSource.get(leftval));
								factToSource.get(leftval).clear();
								factToSource.get(leftval).addAll(sourceSet);
							}else{
								ArrayList<String> newList = new ArrayList<String>();
								newList.addAll(srcMethods);
								factToSource.put(leftval, newList);
	
							}

							
							System.out.println("uflowIntoThis");
							System.out.println(uFlowIntoThis);
						}

						
						
					}
					

				}




			}



		}
		predFactSet.union(uFlowIntoThis);//union of newly generated facts with exisiting facts 
		System.out.println("out"+predFactSet);
		copy(predFactSet,out);//give the union of newly generated facts with exisiting facts to out for the next nodes for doanalysis 

		System.out.println("Unit to Set "+unitToSet);



		
	}




    @Override
	protected Object entryInitialFlow(){
		

		return emptySet.clone();
	}

	@Override
	protected Object newInitialFlow(){
		

		return emptySet.clone();
	}

    public Map<Unit, ArraySparseSet> getUnitToSet(){
		
		return this.unitToSet;
	}
}   







