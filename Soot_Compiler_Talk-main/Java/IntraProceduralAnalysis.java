

import java.util.*;
import java.io.File;

import soot.*;
import soot.BodyTransformer;
import soot.PackManager;
import soot.Transform;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.jimple.InvokeExpr;
import soot.jimple.Jimple;
import soot.jimple.Stmt;
import soot.options.Options;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.graph.UnitGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.SmartLocalDefs;
import soot.toolkits.scalar.SimpleLiveLocals;
import soot.jimple.StaticInvokeExpr;




public class IntraProceduralAnalysis extends BodyTransformer{

    public static void main(String args[]){
        String mainclass = "GCD";

        //set classpath
	    String javapath = System.getProperty("java.class.path");
	    String jredir = System.getProperty("java.home")+"/lib/rt.jar";
	    String path = javapath+File.pathSeparator+jredir;
	    Scene.v().setSootClassPath(path);

        
        IntraProceduralAnalysis analysis = new IntraProceduralAnalysis();
		PackManager.v().getPack("jtp").add(new Transform("jtp.A1TestDataFlowAnalysis", analysis));

		Options.v().set_app(true);

		SootClass appclass = Scene.v().loadClassAndSupport(mainclass);
	    Scene.v().setMainClass(appclass);
		System.out.println("Main Class Deepak:" + String.valueOf(Scene.v().getMainClass()));

        //set the class to be analysed
        // SootClass s=Scene.v().getMainClass();

        //loop through each method and try to print the function name and check if it has active body or not
        // for(SootMethod m:s.getMethods()){
		// 	System.out.println(m.getName());
		// 	if(!m.hasActiveBody()){
		// 		System.out.println("deepak");
		// 		continue;
		// 	}
		// }
		



	    Scene.v().loadNecessaryClasses();
	    PackManager.v().runPacks();
    }

    @Override
	protected void internalTransform(Body b, String phaseName,
		Map<String, String> options) 
		{
		


			SootClass s=Scene.v().getMainClass();
		
         //loop through each method and try to print the function name and check if it has active body or not
		for(SootMethod m:s.getMethods()){

			System.out.println(m.getName());
			if(!m.hasActiveBody()){
				System.out.println("deepak");
				continue;
			}

			Body methodbody = m.retrieveActiveBody();

			

			//Body methodBody=m.getActiveBody();

			System.out.println("method body for"+m);

			System.out.println(methodbody);


			//System.out.println(s);

			// UnitGraph cfg=new ExceptionalUnitGraph(methodbody);

            ExceptionalUnitGraph eug = new ExceptionalUnitGraph(methodbody);
		
		    ByteForwardFlowAnalysis res = new ByteForwardFlowAnalysis(eug, m);
		    System.out.println(res.getUnitToSet());
			
			
			// System.out.println("Start of the grph");
			// Iterator ig=cfg.iterator();
			// System.out.println("---------------------------------");

			// while(ig.hasNext()){
			// 	Unit u=(Unit)ig.next();
			// 	System.out.println(" unit "+u);

				

			// 	List<ValueBox> uses = u.getUseBoxes();
			// 	Stmt stmt = (Stmt) u;

			// 	for(ValueBox v:uses){
			// 		System.out.println(" values "+ v);


			// 	}

			// 	if(stmt.containsInvokeExpr()){
			// 		System.out.println(" has invoke ");

			// 		InvokeExpr invoke = stmt.getInvokeExpr();
			// 		if(invoke instanceof StaticInvokeExpr){
			// 			StaticInvokeExpr iie = (StaticInvokeExpr) invoke;
			// 			//Value base = iie.getBase();
			// 			List<Value> vals = iie.getArgs();
			// 			System.out.println(" args "+vals);
			// 		}
			// 	}




				

			// }

			

		}

		
	  
	  
	  
	  
	  
  }

}
    

