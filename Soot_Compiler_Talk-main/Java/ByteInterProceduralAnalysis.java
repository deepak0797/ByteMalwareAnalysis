import java.util.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import soot.Body;
import soot.Hierarchy;
import soot.Local;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.ValueBox;
import soot.jimple.ArrayRef;
import soot.jimple.AssignStmt;
import soot.jimple.CaughtExceptionRef;
import soot.jimple.ClassConstant;
import soot.jimple.FieldRef;
import soot.jimple.IdentityStmt;
import soot.jimple.InstanceFieldRef;
import soot.jimple.InstanceInvokeExpr;
import soot.jimple.StaticInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.Jimple;
import soot.jimple.ParameterRef;
import soot.jimple.ReturnStmt;
import soot.jimple.Stmt;
import soot.toolkits.graph.DirectedGraph;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.FlowSet;
import soot.toolkits.scalar.ForwardFlowAnalysis;
import soot.toolkits.scalar.SimpleLiveLocals;
import soot.toolkits.scalar.SimpleLocalUses;
import soot.toolkits.scalar.SmartLocalDefs;
import soot.util.Chain;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.Sources;


public class ByteInterProceduralAnalysis {

    public static Map<SootMethod,ByteMethodSummary> methodSummaryMap= new HashMap<SootMethod,ByteMethodSummary>();
    Iterator<SootMethod> it;
    CallGraph cg_;
    Queue<SootMethod> worklist=new LinkedList<SootMethod>();


    public ByteInterProceduralAnalysis(CallGraph cg,
		Iterator heads) {

        it = heads;
        this.cg_=cg;

		//methodSummaryMap.clear();

        while(it.hasNext()){
            SootMethod m=it.next();
            methodSummaryMap.put(m,newInitialSummary());
            this.worklist.add(m);
        }

		doAnalysis();

        

	}

    // public Map getData(){
    //     return this.data;
    // }


    
	protected ByteMethodSummary newInitialSummary() {

        ByteMethodSummary summary=new ByteMethodSummary();
        

		
		return summary;
	}

    
	

    // @Override
	// protected void copy(Object source, Object dest) {
	
	// }

    // @Override
	// protected void merge(Object in1, Object in2, Object out) {
		
	// }

    // @Override
	protected void applySummary(ByteMethodSummary sum,Unit unit,Stmt stmt,ArraySparseSet dest,FlowSet facts,Map<Value,ArrayList<String>> factSrc,Map<Value,ArrayList<String>> destSrc) {

        //filter only the args that are facts
        List<Value> argValues=stmt.getInvokeExpr().getArgs();
        Set<Value> argFacts=new HashSet<Value>();


        
        HashMap<Integer, HashSet<String>> argToSink=sum.getArgToSink();
        HashMap<Integer, Boolean> argToReturn=sum.getArgToReturn();
        HashSet<String> srcToReturn=sum.getsrcToReturn();
        
        for(int i=0;i<argValues.size();i++){
            Value argVal=argValues.get(i);
            if(facts.contains(argVal) && factSrc.containsKey(argVal)){
                if(argToSink.containsKey(i)){
                    HashSet<String> argSinks=argToSink.get(i);
                    ArrayList<String> argFactSrc=factSrc.get(argVal);
                    ArrayList<String> argSinkList=new ArrayList<>(argSinks);
                    ;
                    //we have the list of sources and sinks

                    for(String src:argFactSrc){
                        for(String sink:argSinkList){
                            System.out.println("*******souce and sink pair found*********"+" source:"+src+" sink: "+sink);

                        }
                    }
                    }


                if(argToReturn.containsKey(i) && argToReturn.get(i)){
                    ArrayList<String> sources=factSrc.get(argVal);
                    List<ValueBox> leftOp=unit.getDefBoxes();
					for(ValueBox leftvb:leftOp){
						Value leftval=leftvb.getValue();
						
						dest.add(leftval);
                        
						if(destSrc.containsKey(leftval)){
                            destSrc.get(leftval).addAll(sources);
                            Set<String> sourceSet = new LinkedHashSet<String>();
                            sourceSet.addAll(destSrc.get(leftval));
                            destSrc.get(leftval).clear();
                            destSrc.get(leftval).addAll(sourceSet);
						}else{
							ArrayList<String> newList = new ArrayList<String>();
							newList.addAll(sources);
							destSrc.put(leftval, newList);

						}
                    }

                }
                
                
            }
        }

        if(srcToReturn.size()>0){
            List<ValueBox> leftOp=unit.getDefBoxes();

        
        
            for(ValueBox leftvb:leftOp){
                Value leftval=leftvb.getValue();
                            
                dest.add(leftval);
                            
                if(destSrc.containsKey(leftval)){
                    destSrc.get(leftval).addAll(srcToReturn);
                    Set<String> sourceSet = new LinkedHashSet<String>();
                    sourceSet.addAll(destSrc.get(leftval));
                    destSrc.get(leftval).clear();
                    destSrc.get(leftval).addAll(sourceSet);
                }else{
                    ArrayList<String> newList = new ArrayList<String>();
                    newList.addAll(srcToReturn);
                    destSrc.put(leftval, newList);

                    }
                }
        }


}

    
	protected void analyseMethod(SootMethod method,ByteMethodSummary summary) {
		
		
		Body body = method.retrieveActiveBody();
		ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);
		
		ByteForwardFlowAnalysis res = new ByteForwardFlowAnalysis(eug,method,body,this,summary);
		
	}

    protected boolean compareSummary(ByteMethodSummary Osummary,ByteMethodSummary Nsummary){
        //compare arg to sink
        return ByteMethodSummary.isMethodSummaryEqual(Osummary, Nsummary);
    }
    protected void analysecall(SootMethod method,Unit unit,Stmt callstmt,ArraySparseSet dest,FlowSet facts,Map<Value,ArrayList<String>> factSrc,Map<Value,ArrayList<String>> destSrc)
    {
        ByteMethodSummary summary=ByteInterProceduralAnalysis.methodSummaryMap.get(method);

        //System.out.println("from map"+ByteInterProceduralAnalysis.methodSummaryMap.get(method));



        //System.out.println(ByteInterProceduralAnalysis.methodSummaryMap);

        //System.out.println("print argtosink"+summary);

        applySummary(summary,unit,callstmt,dest,facts,factSrc,destSrc);

    }
    
    protected void doAnalysis() {
        
        

       
         
     
        while(!this.worklist.isEmpty()){
            SootMethod method=worklist.poll();
            ByteMethodSummary newSummary=newInitialSummary();
            ByteMethodSummary oldSummary=methodSummaryMap.get(method);
            
            System.out.println("^^^^^^ANALYZE METHOD FOR^^^^"+method.toString());
            analyseMethod(method, newSummary);//we need to implement this method
            

            if(!ByteMethodSummary.isMethodSummaryEqual(newSummary, oldSummary)){
                ByteInterProceduralAnalysis.methodSummaryMap.put(method, newSummary);

                Iterator sources=new Sources(cg_.edgesInto(method));



                while(sources.hasNext()){
                    SootMethod src=(SootMethod)sources.next();
                    this.worklist.add(src);


            }
        }
            
            
        }
     
         
       




    
}
}
