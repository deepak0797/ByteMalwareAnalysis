import soot.Scene;
import soot.SootClass;
import soot.SceneTransformer;
import soot.SootMethod;
import soot.jimple.toolkits.callgraph.CHATransformer;    
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.Edge;
import soot.jimple.toolkits.callgraph.Sources;
import soot.util.queue.QueueReader;
import soot.util.Chain;
import soot.jimple.toolkits.callgraph.ReachableMethods;
import soot.MethodOrMethodContext;

import java.util.Iterator;
import java.util.Map;
import java.util.*;

public class CallGraphTransformer extends SceneTransformer{
    public static CallGraph cg=null;
    public static Set<SootClass> applicationClasses = 
 new HashSet<SootClass>();
 public static Set<SootMethod>
 reachableMethods_  = new HashSet<SootMethod>();

    public CallGraphTransformer() {
		System.out.println("Class: BSCallGraphTransformer" + " Method:BSCallGraphTransformer");
		
	}

    @Override
	protected void internalTransform(String arg0, Map<String, String> arg1) {
        System.out.println("Class: BSCallGraphTransformer" + " Method:InternalTransformer");
		
            
			CHATransformer.v().transform();
			cg = Scene.v().getCallGraph();
            SootClass s=Scene.v().getMainClass();

            System.out.println("main class"+s);

            System.out.println(s.getMethods());

            Chain<SootClass> appClasses = Scene.v().getApplicationClasses();
            for(Iterator it = appClasses.iterator();it.hasNext();){
            SootClass newClass = (SootClass) it.next();
            applicationClasses.add(newClass);
            }
            Set<SootMethod> reachableMethods = new HashSet<SootMethod>();

            ReachableMethods rm = Scene.v().getReachableMethods();
            QueueReader<MethodOrMethodContext> rmIt = rm.listener();
                    //recalculate reachable methods to make it complete
            while (rmIt.hasNext()) {
                SootMethod method = rmIt.next().method();

                if (!method.hasActiveBody()) {
                    continue;
                }

                if(!applicationClasses.contains(method.getDeclaringClass())){
                continue;
            }
            reachableMethods.add(method);
            }
            this.reachableMethods_ = reachableMethods;

            List heads = new LinkedList();
            for(SootMethod method : reachableMethods) {
                if (!method.hasActiveBody()
                                
                ) {
                    continue;
            }
            heads.add(method);
            }

            // for(SootMethod m:s.getMethods()){
            //     String methodName=m.getName();

                

            //     if(methodName.equals("add")){
            //         System.out.println("sources"+cg.edgesInto(m));
            //         Iterator sources=new Sources(cg.edgesInto(m));



            //         while(sources.hasNext()){
            //             SootMethod src=(SootMethod)sources.next();
            //             System.out.println(m + " might be called by " + src);

            //         }
            //     }
            // }

            //System.out.println("cg"+cg);
		
		
	}

    public static void printCG(){
		
		System.out.println(" cg printing:");
		QueueReader<Edge> listener = cg.listener();
        int count=0;
		while(listener.hasNext()){
            count+=1;

			Edge edge = listener.next();
			System.out.println("edge:"+edge.toString());

            if (count==5){
                break;
            }

		}
	}
    
}
